<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Project - Design and Analysis of Algorithms</title>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #e6f7ff; /* Light blue background */
            color: #333;
            line-height: 1.6;
        }

        header {
            background-color: #000; /* Black nav bar */
            color: #fff;
            padding: 1rem 0;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2rem;
        }

        nav {
            background-color: #000; /* Black nav bar */
            color: #fff;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        nav ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
        }

        nav ul li {
            margin: 0 1rem;
        }

        nav ul li a {
            color: #fff;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        nav ul li a:hover {
            color: #1e90ff; /* Hover color */
        }

        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        section {
            margin-bottom: 2rem;
            background-color: #fff; /* White background for sections */
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        section h2 {
            color: #1e90ff; /* Blue for headings */
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }

        section p {
            margin-bottom: 1rem;
        }

        section ul {
            list-style: disc inside;
            margin: 1rem 0;
            padding-left: 1rem;
        }

        footer {
            text-align: center;
            padding: 1rem 0;
            background-color: #000; /* Black footer */
            color: #fff;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
       <main>
        <section id="nature-problems">
            <h2>Problems in Nature</h2>
            <p>
                Many real-world problems draw inspiration from nature, and computational methods offer innovative solutions:
                <ul>
                    <li><strong>Iteration:</strong> Iteration models seasonal phenomena such as weather predictions or environmental growth cycles.</li>
                    <li><strong>Recursion:</strong> Recursive methods mirror natural processes like the branching patterns of trees or fractal coastline structures.</li>
                    <li><strong>Backtracking:</strong> Wildlife migration optimization or finding paths in dense forests are examples of nature-inspired problem-solving.</li>
                </ul>
                By studying these patterns, algorithms can provide efficient and robust solutions.
            </p>
        </section>

        <section id="efficiency">
            <h2>Space and Time Efficiency</h2>
            <p>
                Optimizing space and time is fundamental in algorithm design:
                <ul>
                    <li><strong>Importance:</strong> Time efficiency ensures rapid computation, while space efficiency reduces resource consumption, crucial for IoT or mobile applications.</li>
                    <li><strong>Complexity Classes:</strong> Understanding complexities such as O(1), O(n), and O(n^2) enables a structured evaluation of algorithm performance.</li>
                    <li><strong>Example:</strong> Real-time applications like ride-hailing platforms require both time-efficient routing and space-efficient data storage.</li>
                </ul>
            </p>
        </section>

        <section id="design-principles">
            <h2>Asymptotic Analysis</h2>
            <p>Asymptotic analysis is a crucial technique for evaluating the efficiency of algorithms. It focuses on how the running time or space usage of an algorithm changes as the input size grows arbitrarily large. This allows us to compare algorithms and predict their performance for different input sizes, without needing to implement and test them on specific hardware.</p>

            <p><strong>Big O Notation:</strong> The most common notation for expressing asymptotic upper bounds is Big O notation. It provides an upper bound on the growth rate of an algorithm's resource usage (time or space) as the input size increases. For example, if an algorithm has a time complexity of O(n), it means that the running time grows linearly with the input size.</p>

            <p><strong>Benefits of Asymptotic Analysis:</strong></p>
            <ul>
                <li><strong>Algorithm Comparison:</strong> Enables informed decisions on which algorithm is more efficient for a given problem and input size.</li>
                <li><strong>Predictive Power:</strong> Allows us to predict the performance of an algorithm on large datasets without the need for extensive testing.</li>
                <li><strong>Algorithm Improvement:</strong> Guides the design and refinement of algorithms by identifying areas for optimization.</li>
            </ul>
        </section>

        <section id="tree-structures">
            <h2>Algorithm Design Techniques</h2>
            <p>Algorithm design techniques are systematic approaches to solving problems by breaking them down into smaller, more manageable subproblems and then combining the solutions to these subproblems to obtain the overall solution.</p>

            <p>Some of the key algorithmic design techniques include:</p>
            <ul>
                <li><strong>Divide-and-Conquer:</strong> This technique involves dividing the problem into smaller subproblems, solving the subproblems recursively, and then combining the solutions to obtain the overall solution.
                    <ul>
                        <li><strong>Example:</strong> Merge Sort, Quick Sort, Binary Search</li>
                    </ul>
                </li>
                <li><strong>Greedy Algorithms:</strong> Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum.
                    <ul>
                        <li><strong>Example:</strong> Dijkstra's algorithm for shortest paths, Huffman coding</li>
                    </ul>
                </li>
                <li><strong>Dynamic Programming:</strong> This technique is used when the optimal solution to a problem can be expressed as a combination of optimal solutions to subproblems.
                    <ul>
                        <li><strong>Example:</strong> Fibonacci sequence, Knapsack problem</li>
                    </ul>
                </li>
                <li><strong>Backtracking:</strong> This technique involves exploring all possible solutions to a problem by systematically trying different combinations of choices and discarding paths that do not lead to a solution.
                    <ul>
                        <li><strong>Example:</strong> N-Queens problem, Sudoku solver</li>
                    </ul>
                </li>
            </ul>

            <p>By understanding these techniques, we can approach problem-solving in a more structured and systematic way, increasing our chances of finding efficient and effective solutions.</p>
        </section>

        <section id="array-queries">
            <h2>Array Query Algorithms</h2>
            <p>
                Efficient array queries have a profound impact on data processing:
                <ul>
                    <li><strong>Range Queries:</strong> Data structures like Segment Trees and Fenwick Trees enhance query efficiency.</li>
                    <li><strong>Applications:</strong> From financial data analysis to competitive programming, array query algorithms are indispensable.</li>
                </ul>
            </p>
        </section>

        <section id="tree-graphs">
            <h2>Trees vs Graphs</h2>
            <p>
                Trees and graphs are versatile data structures with distinct applications:
                <ul>
                    <li><strong>Trees:</strong> Suitable for hierarchical data representation like XML or file systems.</li>
                    <li><strong>Graphs:</strong> Representing networks like social media, transportation, or electrical grids.</li>
                </ul>
                Traversals like DFS and BFS enable efficient exploration and processing of these structures.
            </p>
        </section>

        <section id="sorting-searching">
            <h2>Sorting and Searching Algorithms</h2>
            <p>
                Sorting and searching are foundational to data manipulation:
                <ul>
                    <li><strong>Sorting Algorithms:</strong> Merge Sort, Quick Sort, and Heap Sort efficiently arrange data.</li>
                    <li><strong>Searching Algorithms:</strong> Techniques like Binary Search provide fast lookup times.</li>
                    <li><strong>Real-world Use Cases:</strong> Used in database indexing, search engines, and e-commerce applications.</li>
                </ul>
            </p>
        </section>

        <section id="graph-algorithms">
            <h2>Graph Algorithms</h2>
            <p>
                Graph algorithms have diverse real-world applications:
                <ul>
                    <li><strong>Spanning Trees:</strong> Applications include network optimization, minimum spanning tree algorithms like Kruskal's and Prim's.</li>
                    <li><strong>Shortest Paths:</strong> GPS navigation systems and supply chain optimization rely on shortest-path algorithms such as Dijkstra's and Bellman-Ford.</li>
                </ul>
            </p>
        </section>

        <section id="design-techniques">
            <h2>Algorithm Design Techniques</h2>
            <p>
                Algorithm design techniques like brute force, divide-and-conquer, dynamic programming, and greedy approaches are invaluable in solving complex computational problems.
                <ul>
                    <li><strong>Examples:</strong> From string matching with Rabin-Karp to efficient resource allocation, design techniques guide solutions.</li>
                    <li><strong>Takeaway:</strong> The choice of design approach balances simplicity, optimization, and scalability.</li>
                </ul>
            </p>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Naveen Huggi | Portfolio</p>
    </footer>
</body>
</html>
