<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Project - Design and Analysis of Algorithms</title>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #e6f7ff; /* Light blue background */
            color: #333;
            line-height: 1.6;
        }

        header {
            background-color: #000; /* Black nav bar */
            color: #fff;
            padding: 1rem 0;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2rem;
        }

        nav {
            background-color: #000; /* Black nav bar */
            color: #fff;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        nav ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
        }

        nav ul li {
            margin: 0 1rem;
        }

        nav ul li a {
            color: #fff;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        nav ul li a:hover {
            color: #1e90ff; /* Hover color */
        }

        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        section {
            margin-bottom: 2rem;
            background-color: #fff; /* White background for sections */
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        section h2 {
            color: #1e90ff; /* Blue for headings */
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }

        section p {
            margin-bottom: 1rem;
        }

        section ul {
            list-style: disc inside;
            margin: 1rem 0;
            padding-left: 1rem;
        }

        footer {
            text-align: center;
            padding: 1rem 0;
            background-color: #000; /* Black footer */
            color: #fff;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Course Project - Design and Analysis of Algorithms</h1>
    </header>
    <nav>
        <ul>
            <li><a href="#nature-problems">Nature Problems</a></li>
            <li><a href="#efficiency">Space & Time Efficiency</a></li>
            <li><a href="#design-principles">Design Principles</a></li>
            <li><a href="#tree-structures">Tree Structures</a></li>
            <li><a href="#array-queries">Array Queries</a></li>
            <li><a href="#tree-graphs">Trees vs Graphs</a></li>
            <li><a href="#sorting-searching">Sorting & Searching</a></li>
            <li><a href="#graph-algorithms">Graph Algorithms</a></li>
            <li><a href="#design-techniques">Design Techniques</a></li>
        </ul>
    </nav>
    <main>
        <section id="nature-problems">
            <h2>Problems in Nature</h2>
            <p>
                Many real-world problems draw inspiration from nature, and computational methods offer innovative solutions:
                <ul>
                    <li><strong>Iteration:</strong> Iteration models seasonal phenomena such as weather predictions or environmental growth cycles.</li>
                    <li><strong>Recursion:</strong> Recursive methods mirror natural processes like the branching patterns of trees or fractal coastline structures.</li>
                    <li><strong>Backtracking:</strong> Wildlife migration optimization or finding paths in dense forests are examples of nature-inspired problem-solving.</li>
                </ul>
                By studying these patterns, algorithms can provide efficient and robust solutions.
            </p>
        </section>

        <section id="efficiency">
            <h2>Space and Time Efficiency</h2>
            <p>
                Optimizing space and time is fundamental in algorithm design:
                <ul>
                    <li><strong>Importance:</strong> Time efficiency ensures rapid computation, while space efficiency reduces resource consumption, crucial for IoT or mobile applications.</li>
                    <li><strong>Complexity Classes:</strong> Understanding complexities such as O(1), O(n), and O(n^2) enables a structured evaluation of algorithm performance.</li>
                    <li><strong>Example:</strong> Real-time applications like ride-hailing platforms require both time-efficient routing and space-efficient data storage.</li>
                </ul>
            </p>
        </section>

        <section id="design-principles">
            <h2>Takeaways from Design Principles</h2>
            <p>
                The following principles have been pivotal in algorithm design:
                <ul>
                    <li><strong>Divide and Conquer:</strong> Splitting problems into sub-problems, as seen in Merge Sort and Quick Sort.</li>
                    <li><strong>Greedy Algorithms:</strong> Used in scenarios like event scheduling, where immediate decisions lead to optimal solutions.</li>
                    <li><strong>Dynamic Programming:</strong> Techniques like the Knapsack Problem illustrate the power of memoization to solve overlapping sub-problems.</li>
                    <li><strong>Backtracking:</strong> Finding valid Sudoku solutions or optimal travel itineraries demonstrates its power.</li>
                </ul>
                These strategies not only streamline problem-solving but also build a structured approach to tackling real-world challenges.
            </p>
        </section>

        <section id="tree-structures">
            <h2>Hierarchical Data - Trees</h2>
            <p>
                Tree data structures are crucial for organizing hierarchical information:
                <ul>
                    <li><strong>Binary Trees:</strong> Optimize data search and retrieval operations.</li>
                    <li><strong>AVL Trees:</strong> Maintain balance for efficient operations in database indexing.</li>
                    <li><strong>Red-Black Trees:</strong> Ensure balance in applications like memory allocation.</li>
                    <li><strong>Heap:</strong> Priority queues in operating systems or real-time schedulers use heaps.</li>
                    <li><strong>Trie:</strong> Powering autocomplete features in search engines by optimizing prefix-based queries.</li>
                </ul>
                These structures underpin many applications, from search engines to operating systems.
            </p>
        </section>

        <section id="array-queries">
            <h2>Array Query Algorithms</h2>
            <p>
                Efficient array queries have a profound impact on data processing:
                <ul>
                    <li><strong>Range Queries:</strong> Data structures like Segment Trees and Fenwick Trees enhance query efficiency.</li>
                    <li><strong>Applications:</strong> From financial data analysis to competitive programming, array query algorithms are indispensable.</li>
                </ul>
            </p>
        </section>

        <section id="tree-graphs">
            <h2>Trees vs Graphs</h2>
            <p>
                Trees and graphs are versatile data structures with distinct applications:
                <ul>
                    <li><strong>Trees:</strong> Suitable for hierarchical data representation like XML or file systems.</li>
                    <li><strong>Graphs:</strong> Representing networks like social media, transportation, or electrical grids.</li>
                </ul>
                Traversals like DFS and BFS enable efficient exploration and processing of these structures.
            </p>
        </section>

        <section id="sorting-searching">
            <h2>Sorting and Searching Algorithms</h2>
            <p>
                Sorting and searching are foundational to data manipulation:
                <ul>
                    <li><strong>Sorting Algorithms:</strong> Merge Sort, Quick Sort, and Heap Sort efficiently arrange data.</li>
                    <li><strong>Searching Algorithms:</strong> Techniques like Binary Search provide fast lookup times.</li>
                    <li><strong>Real-world Use Cases:</strong> Used in database indexing, search engines, and e-commerce applications.</li>
                </ul>
            </p>
        </section>

        <section id="graph-algorithms">
            <h2>Graph Algorithms</h2>
            <p>
                Graph algorithms have diverse real-world applications:
                <ul>
                    <li><strong>Spanning Trees:</strong> Applications include network optimization, minimum spanning tree algorithms like Kruskal's and Prim's.</li>
                    <li><strong>Shortest Paths:</strong> GPS navigation systems and supply chain optimization rely on shortest-path algorithms such as Dijkstra's and Bellman-Ford.</li>
                </ul>
            </p>
        </section>

        <section id="design-techniques">
            <h2>Algorithm Design Techniques</h2>
            <p>
                Algorithm design techniques like brute force, divide-and-conquer, dynamic programming, and greedy approaches are invaluable in solving complex computational problems. 
                <ul>
                    <li><strong>Examples:</strong> From string matching with Rabin-Karp to efficient resource allocation, design techniques guide solutions.</li>
                    <li><strong>Takeaway:</strong> The choice of design approach balances simplicity, optimization, and scalability.</li>
                </ul>
            </p>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Naveen Huggi | Portfolio</p>
    </footer>
</body>
</html>
