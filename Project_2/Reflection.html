<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Project - Design and Analysis of Algorithms</title>
    <style>
        /* General Styling */
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1f4037, #99f2c8);
            color: #fff;
            line-height: 1.6;
        }

        h1, h2 {
            text-align: center;
            text-transform: uppercase;
        }

        main {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        section {
            margin-bottom: 30px;
        }

        section h2 {
            color: #ffdf00;
            border-bottom: 2px solid #ffdf00;
            display: inline-block;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        p {
            margin: 10px 0;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        ul li {
            background: #333;
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
            transition: transform 0.2s, background 0.2s;
        }

        ul li:hover {
            transform: scale(1.05);
            background: #555;
        }

        a {
            color: #ffdf00;
            text-decoration: none;
            font-weight: bold;
        }

        a:hover {
            text-decoration: underline;
        }

        footer {
            text-align: center;
            padding: 10px 0;
            background: rgba(0, 0, 0, 0.8);
            margin-top: 30px;
            border-top: 2px solid #ffdf00;
        }

        footer p {
            margin: 0;
            color: #ffdf00;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            main {
                padding: 15px;
            }

            section h2 {
                font-size: 1.5em;
            }

            ul li {
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            ul li {
                font-size: 0.8em;
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <main>
        <section id="nature-problems">
            <h2>Problems in Nature</h2>
            <p>
                Many real-world problems draw inspiration from nature, and computational methods offer innovative solutions:
                <ul>
                    <li><strong>Iteration:</strong> Iteration models seasonal phenomena such as weather predictions or environmental growth cycles.</li>
                    <li><strong>Recursion:</strong> Recursive methods mirror natural processes like the branching patterns of trees or fractal coastline structures.</li>
                    <li><strong>Backtracking:</strong> Wildlife migration optimization or finding paths in dense forests are examples of nature-inspired problem-solving.</li>
                </ul>
                By studying these patterns, algorithms can provide efficient and robust solutions.
            </p>
        </section>

        <section id="efficiency">
            <h2>Space and Time Efficiency</h2>
            <p>
                Optimizing space and time is fundamental in algorithm design:
                <ul>
                    <li><strong>Importance:</strong> Time efficiency ensures rapid computation, while space efficiency reduces resource consumption, crucial for IoT or mobile applications.</li>
                    <li><strong>Complexity Classes:</strong> Understanding complexities such as O(1), O(n), and O(n^2) enables a structured evaluation of algorithm performance.</li>
                    <li><strong>Example:</strong> Real-time applications like ride-hailing platforms require both time-efficient routing and space-efficient data storage.</li>
                </ul>
            </p>
        </section>

        <section id="design-principles">
            <h2>Takeaways from Design Principles</h2>
            <p>
                The following principles have been pivotal in algorithm design:
                <ul>
                    <li><strong>Divide and Conquer:</strong> Splitting problems into sub-problems, as seen in Merge Sort and Quick Sort.</li>
                    <li><strong>Greedy Algorithms:</strong> Used in scenarios like event scheduling, where immediate decisions lead to optimal solutions.</li>
                    <li><strong>Dynamic Programming:</strong> Techniques like the Knapsack Problem illustrate the power of memoization to solve overlapping sub-problems.</li>
                    <li><strong>Backtracking:</strong> Finding valid Sudoku solutions or optimal travel itineraries demonstrates its power.</li>
                </ul>
                These strategies not only streamline problem-solving but also build a structured approach to tackling real-world challenges.
            </p>
        </section>

        <section id="tree-structures">
            <h2>Hierarchical Data - Trees</h2>
            <p>
                Tree data structures are crucial for organizing hierarchical information:
                <ul>
                    <li><strong>Binary Trees:</strong> Optimize data search and retrieval operations.</li>
                    <li><strong>AVL Trees:</strong> Maintain balance for efficient operations in database indexing.</li>
                    <li><strong>Red-Black Trees:</strong> Ensure balance in applications like memory allocation.</li>
                    <li><strong>Heap:</strong> Priority queues in operating systems or real-time schedulers use heaps.</li>
                    <li><strong>Trie:</strong> Powering autocomplete features in search engines by optimizing prefix-based queries.</li>
                </ul>
                These structures underpin many applications, from search engines to operating systems.
            </p>
        </section>

        <section id="array-queries">
            <h2>Array Query Algorithms</h2>
            <p>
                Efficient array queries have a profound impact on data processing:
                <ul>
                    <li><strong>Range Queries:</strong> Data structures like Segment Trees and Fenwick Trees enhance query efficiency.</li>
                    <li><strong>Applications:</strong> From financial data analysis to competitive programming, array query algorithms are indispensable.</li>
                </ul>
            </p>
        </section>

        <section id="tree-graphs">
            <h2>Trees vs Graphs</h2>
            <p>
                Trees and graphs are versatile data structures with distinct applications:
                <ul>
                    <li><strong>Trees:</strong> Suitable for hierarchical data representation like XML or file systems.</li>
                    <li><strong>Graphs:</strong> Representing networks like social media, transportation, or electrical grids.</li>
                </ul>
                Traversals like DFS and BFS enable efficient exploration and processing of these structures.
            </p>
        </section>

        <section id="sorting-searching">
            <h2>Sorting and Searching Algorithms</h2>
            <p>
                Sorting and searching are foundational to data manipulation:
                <ul>
                    <li><strong>Sorting Algorithms:</strong> Merge Sort, Quick Sort, and Heap Sort efficiently arrange data.</li>
                    <li><strong>Searching Algorithms:</strong> Techniques like Binary Search provide fast lookup times.</li>
                    <li><strong>Real-world Use Cases:</strong> Used in database indexing, search engines, and e-commerce applications.</li>
                </ul>
            </p>
        </section>

        <section id="graph-algorithms">
            <h2>Graph Algorithms</h2>
            <p>
                Graph algorithms have diverse real-world applications:
                <ul>
                    <li><strong>Spanning Trees:</strong> Applications include network optimization, minimum spanning tree algorithms like Kruskal's and Prim's.</li>
                    <li><strong>Shortest Paths:</strong> GPS navigation systems and supply chain optimization rely on shortest-path algorithms such as Dijkstra's and Bellman-Ford.</li>
                </ul>
            </p>
        </section>

        <section id="design-techniques">
            <h2>Algorithm Design Techniques</h2>
            <p>
                Algorithm design techniques like brute force, divide-and-conquer, dynamic programming, and greedy approaches are invaluable in solving complex computational problems. 
                <ul>
                    <li><strong>Examples:</strong> From string matching with Rabin-Karp to efficient resource allocation, design techniques guide solutions.</li>
                    <li><strong>Takeaway:</strong> The choice of design approach balances simplicity, optimization, and scalability.</li>
                </ul>
            </p>
        </section>
    </main>

    <footer>
        <p>&copy; 2024 Naveen Huggi | Portfolio</p>
    </footer>
</body>
</html>
