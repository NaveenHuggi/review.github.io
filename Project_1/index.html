<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 1 - Design and Analysis of Algorithms</title>
<link rel="stylesheet" href="styles.css">

</head>
<body>
    <header>
        <h1>Project 1: Structured Enquiry of Design and Analysis of Algorithms</h1>
     <p>This project aims to demonstrate the key concepts I have learned, 
         along with the major challenges encountered during the process.
         It explores how these challenges are linked to real-world applications and 
         how I applied the most efficient approaches to solve complex problems in each area of enquiry.</p>

    </header>
    <main>
        <section>
            <h2>Key Concepts Covered:</h2>
            <ul>
                <li>Time Complexity Analysis</li>
                <li>Binary Search Tree</li>
                <li>DFS and BFS</li>
                <li>Heap</li>
                <li>Sorting</li>
                <li>Pattern Searching</li>
                <li>Graph Algorithms</li>
            </ul>
        </section>
    </main>
    <main>
        <section>
            <h2>Reflection on Key Concepts</h2>

            <h3>1. Time Complexity Analysis</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Grasping how time complexity affects algorithm performance, especially for nested loops and recursion.</li>
                <li>Understanding the nuances of Big-O, Big-Theta, and Big-Omega notations.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying theoretical complexity analysis to real-world scenarios where inputs are dynamic or unpredictable.</li>
                <li>Estimating worst-case vs. average-case performance in practical settings.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Compare algorithms using their time complexity for the given constraints.</li>
                <li>Test algorithms on varying input sizes to validate theoretical analysis.</li>
            </ul>

            <h3>2. Binary Search Tree (BST)</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Understanding tree traversal methods like in-order, pre-order, and post-order.</li>
                <li>Dealing with edge cases such as duplicate elements and imbalanced trees.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Adapting BSTs for dynamic datasets, like in databases or file systems.</li>
                <li>Implementing operations like insertion, deletion, and search in real-time systems.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Ensure the tree remains balanced (e.g., use AVL or Red-Black trees).</li>
                <li>Optimize traversal based on the frequency of access to specific nodes.</li>
            </ul>

            <h3>3. DFS and BFS</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Visualizing the traversal process for complex graphs with cycles.</li>
                <li>Implementing DFS and BFS with appropriate data structures (e.g., stack for DFS, queue for BFS).</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying BFS for shortest-path problems and DFS for pathfinding in graphs.</li>
                <li>Handling memory constraints in BFS for large graphs.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use BFS for scenarios requiring level-order exploration (e.g., social networks).</li>
                <li>Use DFS for scenarios requiring exhaustive exploration (e.g., puzzle-solving).</li>
                <li>Code for BFS</li>
                <p>
                    #include <iostream>
using namespace std;

 void DFS(int start) {
        vector<bool> visited(vertices, false);
        cout << "DFS Traversal: ";
        DFSUtil(start, visited);
        cout << endl;
    }

    void DFSUtil(int v, vector<bool>& visited) {
        visited[v] = true;
        cout << v << " ";

        for (int i = 0; i < vertices; i++) {
            if (adjMatrix[v][i] == 1 && !visited[i]) {
                DFSUtil(i, visited);
            }
        }
    }

void bfs(int m[10][10], int v, int source) {
    int queue[20];
    int front = 0, rear = 0, u, i;
    int visited[10];

    for (i = 0; i < v; i++)
        visited[i] = 0;

    queue[rear] = source;
    visited[source] = 1;

    cout << "The BFS Traversal is... \n";

    while (front <= rear) {
        u = queue[front];
        cout << u << "\t";
        front++;

        for (i = 0; i < v; i++) {
            if (m[u][i] == 1 && visited[i] == 0) {
                visited[i] = 1;
                rear++;
                queue[rear] = i;
            }
        }
    }
}

int main() {
    int v = 5;
    int m[10][10] = {{0,1,1,0,0}, {1,0,0,1,1},
        {1,0,0,0,1}, {0,1,0,0,0}, {0,1,1,0,0}};

    int source;
    cout << "Enter the source vertex: ";
    cin >> source;

    bfs(m, v, source);

    return 0;
}                
                </p>
            </ul>

            <h3>4. Heap</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Understanding how heaps are structured and maintained during insertion and deletion.</li>
                <li>Differentiating between min-heaps and max-heaps and their applications.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Using heaps in priority queues for task scheduling or resource allocation.</li>
                <li>Implementing heaps for real-time applications where performance is critical.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use binary heaps for simplicity and Fibonacci heaps for better amortized time complexity in specific cases.</li>
                <li>Optimize heapify operations for large datasets.</li>
                <li>Code for Heap</li>
                <p>#include <bits/stdc++.h>
using namespace std;

class Heap {
public:
    int arr[100];
    int size1;
    Heap() {
        arr[0] = -1;
        size1 = 0;
    }
    void insert_heap(int val);
    void display();
    void delete_heap();
};


void Heap::insert_heap(int val) {
    size1 = size1 + 1;
    int index = size1;
    arr[index] = val;
    while (index > 1) {
        int parent = index/2;
        if (arr[parent]<arr[index])
        {
            swap(arr[parent], arr[index]);
            index = parent;
        }
        else {
            return;
        }
    }
}

void Heap::delete_heap()
{
    arr[1] = arr[size1];
    int i = 1;
    while(i<size1)
    {
        int li = 2*i;
        int ri = 2*i +1;

        if(i<li && arr[i]<arr[li])
        {
            swap(arr[i],arr[li]);
            i = li;
        }
        if(i<ri && arr[i]<arr[ri])
        {
            swap(arr[i],arr[ri]);
            i = ri;
        }else{
            return;
        }
        size1--;

    }
}

void Heap::display() {
    for (int i = 1; i <= size1; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    Heap h;
    h.insert_heap(7);
    h.insert_heap(12);
    h.insert_heap(5);
    h.insert_heap(15);
    h.insert_heap(10);
    h.insert_heap(20);
    h.delete_heap();

    cout << "Heap elements after insertion: ";
    h.display();
    cout<<h.arr[1]<<endl;
    return 0;
}
                </p>
            </ul>

            <h3>5. Sorting</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Differentiating between various sorting algorithms (e.g., quicksort, mergesort, bubblesort) and their use cases.</li>
                <li>Understanding in-place sorting vs. external sorting for memory-constrained environments.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying sorting in database queries, file systems, and search engines.</li>
                <li>Balancing time complexity with stability requirements for specific use cases.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use quicksort for average-case performance, mergesort for stability, and heapsort for memory efficiency.</li>
                <li>Consider parallel sorting techniques for very large datasets.</li>
                <li>Code for Sorting </li>
                <p>

                  void Sorting::Bubble_sort(int A[],int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-i-1;j++)
        {
            if(A[j]>A[j+1])
            {
                swap(A[j],A[j+1]);
            }
        }
    }

}

void Sorting::Selection_sort(int A[],int n)
{
    for(int i = 0;i<n-1;i++)
    {
        int smallest = i;
        for (int j =i;j<n;j++)
        {
            if(A[j]<A[smallest])
            {
                smallest = j;
            }
        }
        if(smallest != i)
        {
          swap(A[i],A[smallest]);
        }

    }
}  
                </p>
            </ul>

            <h3>6. Pattern Searching</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Understanding different algorithms like KMP, Rabin-Karp, and their complexity.</li>
                <li>Dealing with overlapping patterns and large text datasets.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying pattern searching in text editors, search engines, and bioinformatics.</li>
                <li>Handling noisy data or approximate matches in real-world text processing.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use KMP for deterministic patterns and Rabin-Karp for multiple pattern searching.</li>
                <li>Optimize algorithms for pre-processing and indexing large datasets.</li>
            </ul>

            <h3>7. Graph Algorithms</h3>
            <p><strong>Challenges in learning/understanding:</strong></p>
            <ul>
                <li>Grasping concepts like graph representation (adjacency matrix vs. adjacency list).</li>
                <li>Understanding advanced graph algorithms like Dijkstra’s, Prim’s, and Kruskal’s.</li>
            </ul>
            <p><strong>Challenges in correlating with real-world applications:</strong></p>
            <ul>
                <li>Applying graph algorithms in fields like network optimization, supply chain logistics, and AI pathfinding.</li>
                <li>Balancing accuracy and performance for large graphs in real-time applications.</li>
            </ul>
            <p><strong>How to determine the most efficient approach/design techniques:</strong></p>
            <ul>
                <li>Use adjacency lists for sparse graphs and adjacency matrices for dense graphs.</li>
                <li>Optimize algorithms with heuristics for specific applications (e.g., A* for pathfinding).</li>
            </ul>
        </section>
    </main>
</body>
</html>
